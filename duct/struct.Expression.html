<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `Expression` struct in crate `duct`."><meta name="keywords" content="rust, rustlang, rust-lang, Expression"><title>duct::Expression - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../duct/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Struct Expression</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.before_spawn">before_spawn</a><a href="#method.dir">dir</a><a href="#method.env">env</a><a href="#method.env_remove">env_remove</a><a href="#method.full_env">full_env</a><a href="#method.input">input</a><a href="#method.pipe">pipe</a><a href="#method.read">read</a><a href="#method.run">run</a><a href="#method.start">start</a><a href="#method.stderr">stderr</a><a href="#method.stderr_capture">stderr_capture</a><a href="#method.stderr_handle">stderr_handle</a><a href="#method.stderr_null">stderr_null</a><a href="#method.stderr_to_stdout">stderr_to_stdout</a><a href="#method.stdin">stdin</a><a href="#method.stdin_handle">stdin_handle</a><a href="#method.stdin_null">stdin_null</a><a href="#method.stdout">stdout</a><a href="#method.stdout_capture">stdout_capture</a><a href="#method.stdout_handle">stdout_handle</a><a href="#method.stdout_null">stdout_null</a><a href="#method.stdout_to_stderr">stdout_to_stderr</a><a href="#method.then">then</a><a href="#method.unchecked">unchecked</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-Debug">Debug</a><a href="#impl-From%3C%26%27a%20Expression%3E">From&lt;&amp;&#39;a Expression&gt;</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">!RefUnwindSafe</a><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">!UnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><p class='location'><a href='index.html'>duct</a></p><script>window.sidebarCurrent = {name: 'Expression', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/duct/lib.rs.html#239' title='goto source code'>[src]</a></span><span class='in-band'>Struct <a href='index.html'>duct</a>::<wbr><a class="struct" href=''>Expression</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust struct'><span class="docblock attributes top-attr">#[must_use]
</span>pub struct Expression(_);</pre></div><div class='docblock'><p>The central objects in <code>duct</code>, Expressions are created with
<a href="fn.cmd.html"><code>cmd</code></a> or <a href="macro.cmd.html"><code>cmd!</code></a>, combined with
<a href="struct.Expression.html#method.pipe"><code>pipe</code></a> or
<a href="struct.Expression.html#method.then"><code>then</code></a>, and finally executed with
<a href="struct.Expression.html#method.start"><code>start</code></a>,
<a href="struct.Expression.html#method.run"><code>run</code></a>, or
<a href="struct.Expression.html#method.read"><code>read</code></a>. They also support several
methods to control their execution, like
<a href="struct.Expression.html#method.input"><code>input</code></a>,
<a href="struct.Expression.html#method.env"><code>env</code></a>, and
<a href="struct.Expression.html#method.unchecked"><code>unchecked</code></a>.</p>
<p>Expressions are immutable, and they do a lot of
<a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> sharing
internally, so all of the methods below take <code>&amp;self</code> and return a new
<code>Expression</code> cheaply.</p>
<p>Expressions using <code>then</code> and <code>pipe</code> form trees, and the order in which you
call different methods can matter, just like it matters where you put
redirections in Bash. For example, each of these expressions suppresses
output differently:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Only suppress output from the left side.</span>
<span class="kw">let</span> <span class="ident">suppress_foo</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;foo&quot;</span>).<span class="ident">stdout_null</span>().<span class="ident">then</span>(<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;bar&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">suppress_foo</span>.<span class="ident">read</span>().<span class="ident">unwrap</span>(), <span class="string">&quot;bar&quot;</span>);

<span class="comment">// Only suppress output from the right side.</span>
<span class="kw">let</span> <span class="ident">suppress_bar</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;foo&quot;</span>).<span class="ident">then</span>(<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;bar&quot;</span>).<span class="ident">stdout_null</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">suppress_bar</span>.<span class="ident">read</span>().<span class="ident">unwrap</span>(), <span class="string">&quot;foo&quot;</span>);

<span class="comment">// Suppress output from both sides.</span>
<span class="kw">let</span> <span class="ident">suppress_both</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;foo&quot;</span>).<span class="ident">then</span>(<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;bar&quot;</span>)).<span class="ident">stdout_null</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">suppress_both</span>.<span class="ident">read</span>().<span class="ident">unwrap</span>(), <span class="string">&quot;&quot;</span>);</pre></div>
<p>This version is exactly the same, but with temporary variables to make it
easier to see what's going on:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;foo&quot;</span>);
<span class="kw">let</span> <span class="ident">bar</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;bar&quot;</span>);

<span class="kw">let</span> <span class="ident">foo_null</span> <span class="op">=</span> <span class="ident">foo</span>.<span class="ident">stdout_null</span>();
<span class="kw">let</span> <span class="ident">bar_null</span> <span class="op">=</span> <span class="ident">bar</span>.<span class="ident">stdout_null</span>();

<span class="comment">// Note that you can pass expressions by reference, when you&#39;re using them</span>
<span class="comment">// more than once.</span>
<span class="kw">let</span> <span class="ident">suppress_foo</span> <span class="op">=</span> <span class="ident">foo_null</span>.<span class="ident">then</span>(<span class="kw-2">&amp;</span><span class="ident">bar</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">suppress_foo</span>.<span class="ident">read</span>().<span class="ident">unwrap</span>(), <span class="string">&quot;bar&quot;</span>);

<span class="kw">let</span> <span class="ident">suppress_bar</span> <span class="op">=</span> <span class="ident">foo</span>.<span class="ident">then</span>(<span class="kw-2">&amp;</span><span class="ident">bar_null</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">suppress_bar</span>.<span class="ident">read</span>().<span class="ident">unwrap</span>(), <span class="string">&quot;foo&quot;</span>);

<span class="kw">let</span> <span class="ident">suppress_both</span> <span class="op">=</span> <span class="ident">foo</span>.<span class="ident">then</span>(<span class="ident">bar</span>).<span class="ident">stdout_null</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">suppress_both</span>.<span class="ident">read</span>().<span class="ident">unwrap</span>(), <span class="string">&quot;&quot;</span>);</pre></div>
</div><h2 id='methods' class='small-section-header'>Methods<a href='#methods' class='anchor'></a></h2><h3 id='impl' class='impl'><code class='in-band'>impl <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a href='#impl' class='anchor'></a><a class='srclink' href='../src/duct/lib.rs.html#241-949' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.run' class="method"><code id='run.v'>pub fn <a href='#method.run' class='fnname'>run</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/process/struct.Output.html" title="struct std::process::Output">Output</a>&gt;</code><a class='srclink' href='../src/duct/lib.rs.html#271-273' title='goto source code'>[src]</a></h4><div class='docblock'><p>Execute an expression, wait for it to complete, and return a
<a href="https://doc.rust-lang.org/std/process/struct.Output.html"><code>std::process::Output</code></a>
object containing the results. Nothing is captured by default, but if
you build the expression with
<a href="struct.Expression.html#method.stdout_capture"><code>stdout_capture</code></a> or
<a href="struct.Expression.html#method.stderr_capture"><code>stderr_capture</code></a> then
the <code>Output</code> will hold those captured bytes.</p>
<h1 id="errors" class="section-header"><a href="#errors">Errors</a></h1>
<p>In addition to all the IO errors possible with
<a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>std::process::Command</code></a>,
<code>run</code> will return an
<a href="https://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>ErrorKind::Other</code></a>
IO error if child returns a non-zero exit status. To suppress this error
and return an <code>Output</code> even when the exit status is non-zero, use the
<a href="struct.Expression.html#method.unchecked"><code>unchecked</code></a> method.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;hi&quot;</span>).<span class="ident">stdout_capture</span>().<span class="ident">run</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;hi\n&quot;</span>.<span class="ident">to_vec</span>(), <span class="ident">output</span>.<span class="ident">stdout</span>);</pre></div>
</div><h4 id='method.read' class="method"><code id='read.v'>pub fn <a href='#method.read' class='fnname'>read</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</code><a class='srclink' href='../src/duct/lib.rs.html#298-308' title='goto source code'>[src]</a></h4><div class='docblock'><p>Execute an expression, capture its standard output, and return the
captured output as a <code>String</code>. This is a convenience wrapper around
<a href="struct.Expression.html#method.run"><code>run</code></a>. Like backticks and <code>$()</code> in
the shell, <code>read</code> trims trailing newlines.</p>
<h1 id="errors-1" class="section-header"><a href="#errors-1">Errors</a></h1>
<p>In addition to all the errors possible with
<a href="struct.Expression.html#method.run"><code>run</code></a>, <code>read</code> will return an
<a href="https://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>ErrorKind::InvalidData</code></a>
IO error if the captured bytes aren't valid UTF-8.</p>
<h1 id="example-1" class="section-header"><a href="#example-1">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;hi&quot;</span>).<span class="ident">stdout_capture</span>().<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;hi&quot;</span>, <span class="ident">output</span>);</pre></div>
</div><h4 id='method.start' class="method"><code id='start.v'>pub fn <a href='#method.start' class='fnname'>start</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="../duct/struct.Handle.html" title="struct duct::Handle">Handle</a>&gt;</code><a class='srclink' href='../src/duct/lib.rs.html#341-348' title='goto source code'>[src]</a></h4><div class='docblock'><p>Start running an expression, and immediately return a
<a href="struct.Handle.html"><code>Handle</code></a> that represents all the child processes.
This is analogous to the
<a href="https://doc.rust-lang.org/std/process/struct.Command.html#method.spawn"><code>spawn</code></a>
method in the standard library. The <code>Handle</code> may be shared between
multiple threads.</p>
<h1 id="errors-2" class="section-header"><a href="#errors-2">Errors</a></h1>
<p>In addition to all the errors possible with
<a href="https://doc.rust-lang.org/std/process/struct.Command.html#method.spawn"><code>std::process::Command::spawn</code></a>,
<code>start</code> can return errors from opening pipes and files. However, <code>start</code>
will never return an error if a child process has already started. In
particular, if the left side of a pipe expression starts successfully,
<code>start</code> will always return <code>Ok</code>. Any errors that happen on the right
side will be saved and returned later by the wait methods. That makes it
safe for callers to short circuit on <code>start</code> errors without the risk of
leaking processes.</p>
<h1 id="example-2" class="section-header"><a href="#example-2">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">handle</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;hi&quot;</span>).<span class="ident">stdout_capture</span>().<span class="ident">start</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="ident">handle</span>.<span class="ident">wait</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;hi\n&quot;</span>.<span class="ident">to_vec</span>(), <span class="ident">output</span>.<span class="ident">stdout</span>);</pre></div>
</div><h4 id='method.pipe' class="method"><code id='pipe.v'>pub fn <a href='#method.pipe' class='fnname'>pipe</a>&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a>&gt;&gt;(&amp;self, right: T) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#373-375' title='goto source code'>[src]</a></h4><div class='docblock'><p>Join two expressions into a pipe expression, where the standard output
of the left will be hooked up to the standard input of the right, like
<code>|</code> in the shell.</p>
<h1 id="errors-3" class="section-header"><a href="#errors-3">Errors</a></h1>
<p>During execution, if one side of the pipe returns a non-zero exit
status, that becomes the status of the whole pipe, similar to Bash's
<code>pipefail</code> option. If both sides return non-zero, and one of them is
<a href="struct.Expression.html#method.unchecked"><code>unchecked</code></a>, then the checked
side wins. Otherwise the right side wins.</p>
<h1 id="example-3" class="section-header"><a href="#example-3">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;hi&quot;</span>).<span class="ident">pipe</span>(<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;sed&quot;</span>, <span class="string">&quot;s/h/p/&quot;</span>)).<span class="ident">read</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;pi&quot;</span>, <span class="ident">output</span>.<span class="ident">unwrap</span>());</pre></div>
</div><h4 id='method.then' class="method"><code id='then.v'>pub fn <a href='#method.then' class='fnname'>then</a>&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a>&gt;&gt;(&amp;self, right: T) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#406-408' title='goto source code'>[src]</a></h4><div class='docblock'><p>Join two expressions together into an &quot;A then B&quot; expression, like <code>&amp;&amp;</code>
in the shell.</p>
<h1 id="errors-4" class="section-header"><a href="#errors-4">Errors</a></h1>
<p>During execution, if the left child returns a non-zero exit status, the
right child gets skipped. You can use
<a href="struct.Expression.html#method.unchecked"><code>unchecked</code></a> on the left child
to make sure the right child always runs. The exit status of this
expression is the status of the last child that ran. Note that
<a href="struct.Handle.html#method.kill"><code>kill</code></a> will prevent the right side
from starting if it hasn't already, even if the left side is
<code>unchecked</code>.</p>
<h1 id="example-4" class="section-header"><a href="#example-4">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Both echoes share the same stdout, so both go through `sed`.</span>
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;-n&quot;</span>, <span class="string">&quot;bar&quot;</span>)
    .<span class="ident">then</span>(<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;baz&quot;</span>))
    .<span class="ident">pipe</span>(<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;sed&quot;</span>, <span class="string">&quot;s/b/f/g&quot;</span>)).<span class="ident">read</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;farfaz&quot;</span>, <span class="ident">output</span>.<span class="ident">unwrap</span>());</pre></div>
</div><h4 id='method.input' class="method"><code id='input.v'>pub fn <a href='#method.input' class='fnname'>input</a>&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;&gt;&gt;(&amp;self, input: T) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#429-431' title='goto source code'>[src]</a></h4><div class='docblock'><p>Use bytes or a string as input for an expression, like <code>&lt;&lt;&lt;</code> in the
shell. A worker thread will write the input at runtime.</p>
<h1 id="example-5" class="section-header"><a href="#example-5">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Many types implement Into&lt;Vec&lt;u8&gt;&gt;. Here&#39;s a string.</span>
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;cat&quot;</span>).<span class="ident">input</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;foo&quot;</span>, <span class="ident">output</span>);

<span class="comment">// And here&#39;s a byte slice.</span>
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;cat&quot;</span>).<span class="ident">input</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;foo&quot;</span>[..]).<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;foo&quot;</span>, <span class="ident">output</span>);</pre></div>
</div><h4 id='method.stdin' class="method"><code id='stdin.v'>pub fn <a href='#method.stdin' class='fnname'>stdin</a>&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;&gt;(&amp;self, path: T) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#448-450' title='goto source code'>[src]</a></h4><div class='docblock'><p>Open a file at the given path and use it as input for an expression,
like <code>&lt;</code> in the shell.</p>
<h1 id="example-6" class="section-header"><a href="#example-6">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Many types implement Into&lt;PathBuf&gt;, including &amp;str.</span>
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;head&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;3&quot;</span>).<span class="ident">stdin</span>(<span class="string">&quot;/dev/zero&quot;</span>).<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;\0\0\0&quot;</span>, <span class="ident">output</span>);</pre></div>
</div><h4 id='method.stdin_handle' class="method"><code id='stdin_handle.v'>pub fn <a href='#method.stdin_handle' class='fnname'>stdin_handle</a>&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/trait.IntoRawFd.html" title="trait std::sys::unix::ext::io::IntoRawFd">IntoRawFd</a>&gt;(&amp;self, handle: T) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#467-469' title='goto source code'>[src]</a></h4><div class='docblock'><p>Use an already opened file or pipe as input for an expression.</p>
<h1 id="example-7" class="section-header"><a href="#example-7">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">input_file</span> <span class="op">=</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>::<span class="ident">open</span>(<span class="string">&quot;/dev/zero&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;head&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;3&quot;</span>).<span class="ident">stdin_handle</span>(<span class="ident">input_file</span>).<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;\0\0\0&quot;</span>, <span class="ident">output</span>);</pre></div>
</div><h4 id='method.stdin_null' class="method"><code id='stdin_null.v'>pub fn <a href='#method.stdin_null' class='fnname'>stdin_null</a>(&amp;self) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#488-490' title='goto source code'>[src]</a></h4><div class='docblock'><p>Use <code>/dev/null</code> (or <code>NUL</code> on Windows) as input for an expression.</p>
<h1 id="example-8" class="section-header"><a href="#example-8">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;cat&quot;</span>).<span class="ident">stdin_null</span>().<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;&quot;</span>, <span class="ident">output</span>);</pre></div>
</div><h4 id='method.stdout' class="method"><code id='stdout.v'>pub fn <a href='#method.stdout' class='fnname'>stdout</a>&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;&gt;(&amp;self, path: T) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#511-513' title='goto source code'>[src]</a></h4><div class='docblock'><p>Open a file at the given path and use it as output for an expression,
like <code>&gt;</code> in the shell.</p>
<h1 id="example-9" class="section-header"><a href="#example-9">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Many types implement Into&lt;PathBuf&gt;, including &amp;str.</span>
<span class="kw">let</span> <span class="ident">path</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;mktemp&quot;</span>).<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;wee&quot;</span>).<span class="ident">stdout</span>(<span class="kw-2">&amp;</span><span class="ident">path</span>).<span class="ident">run</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">output</span> <span class="op">=</span> <span class="ident">String</span>::<span class="ident">new</span>();
<span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>::<span class="ident">open</span>(<span class="kw-2">&amp;</span><span class="ident">path</span>).<span class="ident">unwrap</span>().<span class="ident">read_to_string</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">output</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;wee\n&quot;</span>, <span class="ident">output</span>);</pre></div>
</div><h4 id='method.stdout_handle' class="method"><code id='stdout_handle.v'>pub fn <a href='#method.stdout_handle' class='fnname'>stdout_handle</a>&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/trait.IntoRawFd.html" title="trait std::sys::unix::ext::io::IntoRawFd">IntoRawFd</a>&gt;(&amp;self, handle: T) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#534-536' title='goto source code'>[src]</a></h4><div class='docblock'><p>Use an already opened file or pipe as output for an expression.</p>
<h1 id="example-10" class="section-header"><a href="#example-10">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">path</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;mktemp&quot;</span>).<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>::<span class="ident">create</span>(<span class="kw-2">&amp;</span><span class="ident">path</span>).<span class="ident">unwrap</span>();
<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;wee&quot;</span>).<span class="ident">stdout_handle</span>(<span class="ident">file</span>).<span class="ident">run</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">output</span> <span class="op">=</span> <span class="ident">String</span>::<span class="ident">new</span>();
<span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>::<span class="ident">open</span>(<span class="kw-2">&amp;</span><span class="ident">path</span>).<span class="ident">unwrap</span>().<span class="ident">read_to_string</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">output</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;wee\n&quot;</span>, <span class="ident">output</span>);</pre></div>
</div><h4 id='method.stdout_null' class="method"><code id='stdout_null.v'>pub fn <a href='#method.stdout_null' class='fnname'>stdout_null</a>(&amp;self) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#559-561' title='goto source code'>[src]</a></h4><div class='docblock'><p>Use <code>/dev/null</code> (or <code>NUL</code> on Windows) as output for an expression.</p>
<h1 id="example-11" class="section-header"><a href="#example-11">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// This echo command won&#39;t print anything.</span>
<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>).<span class="ident">stdout_null</span>().<span class="ident">run</span>().<span class="ident">unwrap</span>();

<span class="comment">// And you won&#39;t get anything even if you try to read its output! The</span>
<span class="comment">// null redirect happens farther down in the expression tree than the</span>
<span class="comment">// implicit `stdout_capture`, and so it takes precedence.</span>
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>).<span class="ident">stdout_null</span>().<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;&quot;</span>, <span class="ident">output</span>);</pre></div>
</div><h4 id='method.stdout_capture' class="method"><code id='stdout_capture.v'>pub fn <a href='#method.stdout_capture' class='fnname'>stdout_capture</a>(&amp;self) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#587-589' title='goto source code'>[src]</a></h4><div class='docblock'><p>Capture the standard output of an expression. The captured bytes will be
available on the <code>stdout</code> field of the
<a href="https://doc.rust-lang.org/std/process/struct.Output.html"><code>std::process::Output</code></a>
object returned by <a href="struct.Expression.html#method.run"><code>run</code></a> or
<a href="struct.Handle.html#method.wait"><code>wait</code></a>. In the simplest cases,
<a href="struct.Expression.html#method.read"><code>read</code></a> can be more convenient.</p>
<h1 id="example-12" class="section-header"><a href="#example-12">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// The most direct way to read stdout bytes is `stdout_capture`.</span>
<span class="kw">let</span> <span class="ident">output1</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;foo&quot;</span>).<span class="ident">stdout_capture</span>().<span class="ident">run</span>().<span class="ident">unwrap</span>().<span class="ident">stdout</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;foo\n&quot;</span>[..], <span class="kw-2">&amp;</span><span class="ident">output1</span>[..]);

<span class="comment">// The `read` method is a shorthand for `stdout_capture`, and it also</span>
<span class="comment">// does string parsing and newline trimming.</span>
<span class="kw">let</span> <span class="ident">output2</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;foo&quot;</span>).<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;foo&quot;</span>, <span class="ident">output2</span>)</pre></div>
</div><h4 id='method.stdout_to_stderr' class="method"><code id='stdout_to_stderr.v'>pub fn <a href='#method.stdout_to_stderr' class='fnname'>stdout_to_stderr</a>(&amp;self) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#605-607' title='goto source code'>[src]</a></h4><div class='docblock'><p>Join the standard output of an expression to its standard error pipe,
similar to <code>1&gt;&amp;2</code> in the shell.</p>
<h1 id="example-13" class="section-header"><a href="#example-13">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;foo&quot;</span>).<span class="ident">stdout_to_stderr</span>().<span class="ident">stderr_capture</span>().<span class="ident">run</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;foo\n&quot;</span>[..], <span class="kw-2">&amp;</span><span class="ident">output</span>.<span class="ident">stderr</span>[..]);</pre></div>
</div><h4 id='method.stderr' class="method"><code id='stderr.v'>pub fn <a href='#method.stderr' class='fnname'>stderr</a>&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;&gt;(&amp;self, path: T) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#628-630' title='goto source code'>[src]</a></h4><div class='docblock'><p>Open a file at the given path and use it as error output for an
expression, like <code>2&gt;</code> in the shell.</p>
<h1 id="example-14" class="section-header"><a href="#example-14">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Many types implement Into&lt;PathBuf&gt;, including &amp;str.</span>
<span class="kw">let</span> <span class="ident">path</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;mktemp&quot;</span>).<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo wee &gt;&amp;2&quot;</span>).<span class="ident">stderr</span>(<span class="kw-2">&amp;</span><span class="ident">path</span>).<span class="ident">run</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">error_output</span> <span class="op">=</span> <span class="ident">String</span>::<span class="ident">new</span>();
<span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>::<span class="ident">open</span>(<span class="kw-2">&amp;</span><span class="ident">path</span>).<span class="ident">unwrap</span>().<span class="ident">read_to_string</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">error_output</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;wee\n&quot;</span>, <span class="ident">error_output</span>);</pre></div>
</div><h4 id='method.stderr_handle' class="method"><code id='stderr_handle.v'>pub fn <a href='#method.stderr_handle' class='fnname'>stderr_handle</a>&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/trait.IntoRawFd.html" title="trait std::sys::unix::ext::io::IntoRawFd">IntoRawFd</a>&gt;(&amp;self, handle: T) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#651-653' title='goto source code'>[src]</a></h4><div class='docblock'><p>Use an already opened file or pipe as error output for an expression.</p>
<h1 id="example-15" class="section-header"><a href="#example-15">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">path</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;mktemp&quot;</span>).<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>::<span class="ident">create</span>(<span class="kw-2">&amp;</span><span class="ident">path</span>).<span class="ident">unwrap</span>();
<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo wee &gt;&amp;2&quot;</span>).<span class="ident">stderr_handle</span>(<span class="ident">file</span>).<span class="ident">run</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">error_output</span> <span class="op">=</span> <span class="ident">String</span>::<span class="ident">new</span>();
<span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>::<span class="ident">open</span>(<span class="kw-2">&amp;</span><span class="ident">path</span>).<span class="ident">unwrap</span>().<span class="ident">read_to_string</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">error_output</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;wee\n&quot;</span>, <span class="ident">error_output</span>);</pre></div>
</div><h4 id='method.stderr_null' class="method"><code id='stderr_null.v'>pub fn <a href='#method.stderr_null' class='fnname'>stderr_null</a>(&amp;self) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#672-674' title='goto source code'>[src]</a></h4><div class='docblock'><p>Use <code>/dev/null</code> (or <code>NUL</code> on Windows) as error output for an expression.</p>
<h1 id="example-16" class="section-header"><a href="#example-16">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// This echo-to-stderr command won&#39;t print anything.</span>
<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo foo bar baz &gt;&amp;2&quot;</span>).<span class="ident">stderr_null</span>().<span class="ident">run</span>().<span class="ident">unwrap</span>();</pre></div>
</div><h4 id='method.stderr_capture' class="method"><code id='stderr_capture.v'>pub fn <a href='#method.stderr_capture' class='fnname'>stderr_capture</a>(&amp;self) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#692-694' title='goto source code'>[src]</a></h4><div class='docblock'><p>Capture the error output of an expression. The captured bytes will be
available on the <code>stderr</code> field of the <code>Output</code> object returned by
<a href="struct.Expression.html#method.run"><code>run</code></a> or
<a href="struct.Handle.html#method.wait"><code>wait</code></a>.</p>
<h1 id="example-17" class="section-header"><a href="#example-17">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">output_obj</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo foo &gt;&amp;2&quot;</span>).<span class="ident">stderr_capture</span>().<span class="ident">run</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;foo\n&quot;</span>[..], <span class="kw-2">&amp;</span><span class="ident">output_obj</span>.<span class="ident">stderr</span>[..]);</pre></div>
</div><h4 id='method.stderr_to_stdout' class="method"><code id='stderr_to_stdout.v'>pub fn <a href='#method.stderr_to_stdout' class='fnname'>stderr_to_stdout</a>(&amp;self) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#710-712' title='goto source code'>[src]</a></h4><div class='docblock'><p>Join the standard error of an expression to its standard output pipe,
similar to <code>2&gt;&amp;1</code> in the shell.</p>
<h1 id="example-18" class="section-header"><a href="#example-18">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">error_output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo foo &gt;&amp;2&quot;</span>).<span class="ident">stderr_to_stdout</span>().<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;foo&quot;</span>, <span class="ident">error_output</span>);</pre></div>
</div><h4 id='method.dir' class="method"><code id='dir.v'>pub fn <a href='#method.dir' class='fnname'>dir</a>&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;&gt;(&amp;self, path: T) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#747-749' title='goto source code'>[src]</a></h4><div class='docblock'><p>Set the working directory where the expression will execute.</p>
<p>Note that in some languages (Rust and Python at least), there are tricky
platform differences in the way relative exe paths interact with child
working directories. In particular, the exe path will be interpreted
relative to the child dir on Unix, but relative to the parent dir on
Windows. <code>duct</code> considers the Windows behavior correct, so in order to
get that behavior consistently it calls
<a href="https://doc.rust-lang.org/std/fs/fn.canonicalize.html"><code>std::fs::canonicalize</code></a>
on relative exe paths when <code>dir</code> is in use. Paths in this sense are any
program name containing a path separator, regardless of the type. (Note
also that <code>Path</code> and <code>PathBuf</code> program names get a <code>./</code> prepended to
them automatically by the <a href="trait.ToExecutable.html"><code>ToExecutable</code></a>
trait, and so will always contain a separator.)</p>
<h1 id="errors-5" class="section-header"><a href="#errors-5">Errors</a></h1>
<p>Canonicalization can fail on some filesystems, or if the current
directory has been removed, and
<a href="struct.Expression.html#method.run"><code>run</code></a> will return those errors
rather than trying any sneaky workarounds.</p>
<h1 id="example-19" class="section-header"><a href="#example-19">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;pwd&quot;</span>).<span class="ident">dir</span>(<span class="string">&quot;/&quot;</span>).<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;/&quot;</span>, <span class="ident">output</span>);</pre></div>
</div><h4 id='method.env' class="method"><code id='env.v'>pub fn <a href='#method.env' class='fnname'>env</a>&lt;T, U&gt;(&amp;self, name: T, val: U) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsString.html" title="struct std::ffi::os_str::OsString">OsString</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsString.html" title="struct std::ffi::os_str::OsString">OsString</a>&gt;,&nbsp;</span></code><a class='srclink' href='../src/duct/lib.rs.html#764-773' title='goto source code'>[src]</a></h4><div class='docblock'><p>Set a variable in the expression's environment.</p>
<h1 id="example-20" class="section-header"><a href="#example-20">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo $FOO&quot;</span>).<span class="ident">env</span>(<span class="string">&quot;FOO&quot;</span>, <span class="string">&quot;bar&quot;</span>).<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;bar&quot;</span>, <span class="ident">output</span>);</pre></div>
</div><h4 id='method.env_remove' class="method"><code id='env_remove.v'>pub fn <a href='#method.env_remove' class='fnname'>env_remove</a>&lt;T&gt;(&amp;self, name: T) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsString.html" title="struct std::ffi::os_str::OsString">OsString</a>&gt;,&nbsp;</span></code><a class='srclink' href='../src/duct/lib.rs.html#797-805' title='goto source code'>[src]</a></h4><div class='docblock'><p>Remove a variable from the expression's environment.</p>
<p>Note that all the environment functions try to do whatever the platform
does with respect to case sensitivity. That means that
<code>env_remove(&quot;foo&quot;)</code> will unset the uppercase variable <code>FOO</code> on Windows,
but not on Unix.</p>
<h1 id="example-21" class="section-header"><a href="#example-21">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">std</span>::<span class="ident">env</span>::<span class="ident">set_var</span>(<span class="string">&quot;TESTING&quot;</span>, <span class="string">&quot;true&quot;</span>);
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo a${TESTING}b&quot;</span>)
    .<span class="ident">env_remove</span>(<span class="string">&quot;TESTING&quot;</span>)
    .<span class="ident">read</span>()
    .<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;ab&quot;</span>, <span class="ident">output</span>);</pre></div>
</div><h4 id='method.full_env' class="method"><code id='full_env.v'>pub fn <a href='#method.full_env' class='fnname'>full_env</a>&lt;T, U, V&gt;(&amp;self, name_vals: T) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a>U, V<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsString.html" title="struct std::ffi::os_str::OsString">OsString</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsString.html" title="struct std::ffi::os_str::OsString">OsString</a>&gt;,&nbsp;</span></code><a class='srclink' href='../src/duct/lib.rs.html#833-844' title='goto source code'>[src]</a></h4><div class='docblock'><p>Set the expression's entire environment, from a collection of name-value
pairs (like a <code>HashMap</code>). You can use this method to clear specific
variables for example, by collecting the parent's environment, removing
some names from the collection, and passing the result to <code>full_env</code>.
Note that some environment variables are required for normal program
execution (like <code>SystemRoot</code> on Windows), so copying the parent's
environment is usually preferable to starting with an empty one.</p>
<h1 id="example-22" class="section-header"><a href="#example-22">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">env_map</span>: <span class="ident">HashMap</span><span class="op">&lt;</span><span class="kw">_</span>, <span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">std</span>::<span class="ident">env</span>::<span class="ident">vars</span>().<span class="ident">collect</span>();
<span class="ident">env_map</span>.<span class="ident">insert</span>(<span class="string">&quot;FOO&quot;</span>.<span class="ident">into</span>(), <span class="string">&quot;bar&quot;</span>.<span class="ident">into</span>());
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo $FOO&quot;</span>).<span class="ident">full_env</span>(<span class="kw-2">&amp;</span><span class="ident">env_map</span>).<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;bar&quot;</span>, <span class="ident">output</span>);
<span class="comment">// The IntoIterator/Into&lt;OsString&gt; bounds are pretty flexible. Passing</span>
<span class="comment">// by value works here too.</span>
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo $FOO&quot;</span>).<span class="ident">full_env</span>(<span class="ident">env_map</span>).<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;bar&quot;</span>, <span class="ident">output</span>);</pre></div>
</div><h4 id='method.unchecked' class="method"><code id='unchecked.v'>pub fn <a href='#method.unchecked' class='fnname'>unchecked</a>(&amp;self) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#903-905' title='goto source code'>[src]</a></h4><div class='docblock'><p>Prevent a non-zero exit status from short-circuiting a
<a href="struct.Expression.html#method.then"><code>then</code></a> expression or from causing
<a href="struct.Expression.html#method.run"><code>run</code></a> and friends to return an
error. The unchecked exit code will still be there on the <code>Output</code>
returned by <code>run</code>; its value doesn't change.</p>
<p>&quot;Uncheckedness&quot; sticks to an exit code as it bubbles up through
complicated expressions, but it doesn't &quot;infect&quot; other exit codes. So
for example, if only one sub-expression in a pipe has <code>unchecked</code>, then
errors returned by the other side will still be checked. That said,
most commonly you'll just call <code>unchecked</code> right before <code>run</code>, and it'll
apply to an entire expression. This sub-expression stuff doesn't usually
come up unless you have a big pipeline built out of lots of different
pieces.</p>
<h1 id="example-23" class="section-header"><a href="#example-23">Example</a></h1>
<p>Note the differences among these three cases:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Don&#39;t check errors on the left side.</span>
<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">unchecked</span>().<span class="ident">pipe</span>(<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;bar&quot;</span>)).<span class="ident">run</span>()<span class="question-mark">?</span>;

<span class="comment">// Don&#39;t check errors on the right side.</span>
<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">pipe</span>(<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;bar&quot;</span>).<span class="ident">unchecked</span>()).<span class="ident">run</span>()<span class="question-mark">?</span>;

<span class="comment">// Don&#39;t check errors on either side.</span>
<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">pipe</span>(<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;bar&quot;</span>)).<span class="ident">unchecked</span>().<span class="ident">run</span>()<span class="question-mark">?</span>;</pre></div>
<p>As in the type-level docs above, the differences are easier to spot if
we split each expression up into multiple lines, although the meaning
is exactly the same.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Don&#39;t check errors on the left side.</span>
<span class="kw">let</span> <span class="ident">left</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">unchecked</span>();
<span class="ident">left</span>.<span class="ident">pipe</span>(<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;bar&quot;</span>)).<span class="ident">run</span>()<span class="question-mark">?</span>;

<span class="comment">// Don&#39;t check errors on the right side.</span>
<span class="kw">let</span> <span class="ident">right</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;bar&quot;</span>).<span class="ident">unchecked</span>();
<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">pipe</span>(<span class="ident">right</span>).<span class="ident">run</span>()<span class="question-mark">?</span>;

<span class="comment">// Don&#39;t check errors on either side.</span>
<span class="kw">let</span> <span class="ident">pipeline</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">pipe</span>(<span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;bar&quot;</span>));
<span class="ident">pipeline</span>.<span class="ident">unchecked</span>().<span class="ident">run</span>()<span class="question-mark">?</span>;</pre></div>
</div><h4 id='method.before_spawn' class="method"><code id='before_spawn.v'>pub fn <a href='#method.before_spawn' class='fnname'>before_spawn</a>&lt;F&gt;(&amp;self, hook: F) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(&amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/std/process/struct.Command.html" title="struct std::process::Command">Command</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></code><a class='srclink' href='../src/duct/lib.rs.html#939-944' title='goto source code'>[src]</a></h4><div class='docblock'><p>Add a hook for modifying
<a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>std::process::Command</code></a>
objects immediately before they're executed.</p>
<p>The hook is called for each command in its sub-expression, and each time the expression is
executed. The call happens after other features like <code>stdout</code> and <code>env</code> have been applied,
so any changes made by the hook take priority. More than one hook can be added, in which
case the innermost is executed last. For example, if one call to <code>before_spawn</code> is applied
to an entire pipe expression, and another call is applied to just one command within the
pipe, the hook for the entire pipeline will be called first over the command where both
hooks apply.</p>
<p>This is intended for rare and tricky cases, like callers who want to change the group ID of
their child processes, or who want to run code in <code>before_exec</code>. Most callers shouldn't
need to use it.</p>
<h1 id="example-24" class="section-header"><a href="#example-24">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="macro">cmd</span><span class="macro">!</span>(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;foo&quot;</span>)
    .<span class="ident">before_spawn</span>(<span class="op">|</span><span class="ident">cmd</span><span class="op">|</span> {
        <span class="comment">// Sneakily add an extra argument.</span>
        <span class="ident">cmd</span>.<span class="ident">arg</span>(<span class="string">&quot;bar&quot;</span>);
        <span class="prelude-val">Ok</span>(())
    })
    .<span class="ident">read</span>()
    .<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;foo bar&quot;</span>, <span class="ident">output</span>);</pre></div>
</div></div><h2 id='implementations' class='small-section-header'>Trait Implementations<a href='#implementations' class='anchor'></a></h2><div id='implementations-list'><h3 id='impl-From%3C%26%27a%20Expression%3E' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a>&gt; for <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a href='#impl-From%3C%26%27a%20Expression%3E' class='anchor'></a><a class='srclink' href='../src/duct/lib.rs.html#953-957' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from' class="method hidden"><code id='from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(expr: &amp;<a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a>) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#954-956' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Clone' class='impl'><code class='in-band'>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a href='#impl-Clone' class='anchor'></a><a class='srclink' href='../src/duct/lib.rs.html#237' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.clone' class="method hidden"><code id='clone.v'>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a class='srclink' href='../src/duct/lib.rs.html#237' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from' class="method"><code id='clone_from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/clone.rs.html#131-133' title='goto source code'>[src]</a></h4><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 id='impl-Debug' class='impl'><code class='in-band'>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a href='#impl-Debug' class='anchor'></a><a class='srclink' href='../src/duct/lib.rs.html#237' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt' class="method hidden"><code id='fmt.v'>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class='srclink' href='../src/duct/lib.rs.html#237' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div></div><h2 id='synthetic-implementations' class='small-section-header'>Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a></h2><div id='synthetic-implementations-list'><h3 id='impl-Unpin' class='impl'><code class='in-band'>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a href='#impl-Unpin' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><code class='in-band'>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a href='#impl-Sync' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Send' class='impl'><code class='in-band'>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a href='#impl-Send' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-UnwindSafe' class='impl'><code class='in-band'>impl !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a href='#impl-UnwindSafe' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-RefUnwindSafe' class='impl'><code class='in-band'>impl !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../duct/struct.Expression.html" title="struct duct::Expression">Expression</a></code><a href='#impl-RefUnwindSafe' class='anchor'></a></h3><div class='impl-items'></div></div><h2 id='blanket-implementations' class='small-section-header'>Blanket Implementations<a href='#blanket-implementations' class='anchor'></a></h2><div id='blanket-implementations-list'><h3 id='impl-From%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href='#impl-From%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#550-552' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from-1' class="method hidden"><code id='from.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(t: T) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#551' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-ToOwned' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a href='#impl-ToOwned' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#81-92' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Owned' class="type"><code id='Owned.t'>type <a href='https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned' class="type">Owned</a> = T</code></h4><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div><h4 id='method.to_owned' class="method hidden"><code id='to_owned.v'>fn <a href='https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned' class='fnname'>to_owned</a>(&amp;self) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#85-87' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div><h4 id='method.clone_into' class="method hidden"><code id='clone_into.v'>fn <a href='https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into' class='fnname'>clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89-91' title='goto source code'>[src]</a></h4><div class='stability hidden'><div class='stab unstable'><details><summary><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</summary><p>recently added</p>
</details></div></div><div class='docblock hidden'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></div><h3 id='impl-Into%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-Into%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#541-546' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into' class="method hidden"><code id='into.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; U</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#543-545' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryFrom%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryFrom%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#569-575' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error' class="type"><code id='Error.t'>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error' class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_from' class="method hidden"><code id='try_from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from' class='fnname'>try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#572-574' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryInto%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryInto%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#557-564' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error-1' class="type"><code id='Error.t-1'>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error' class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_into' class="method hidden"><code id='try_into.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into' class='fnname'>try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#561-563' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-BorrowMut%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-BorrowMut%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218-220' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow_mut' class="method hidden"><code id='borrow_mut.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut' class='fnname'>borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#219' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id='impl-Borrow%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Borrow%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#213-215' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow' class="method hidden"><code id='borrow.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id='impl-Any' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Any' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#100-102' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.type_id' class="method hidden"><code id='type_id.v'>fn <a href='https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id' class='fnname'>type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#101' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "duct";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>