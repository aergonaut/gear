<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `os_pipe` crate."><meta name="keywords" content="rust, rustlang, rust-lang, os_pipe"><title>os_pipe - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../os_pipe/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate os_pipe</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all os_pipe's items</p></a><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'os_pipe', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/os_pipe/lib.rs.html#1-441' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>os_pipe</a></span></h1><div class='docblock'><p>A cross-platform library for opening OS pipes.</p>
<p>The standard library uses pipes to read output from child processes,
but it doesn't expose a way to create them directly. This crate
fills that gap with the <code>pipe</code> function. It also includes some
helpers for passing pipes to the <code>std::process::Command</code> API.</p>
<ul>
<li><a href="https://docs.rs/os_pipe">Docs</a></li>
<li><a href="https://crates.io/crates/os_pipe">Crate</a></li>
<li><a href="https://github.com/oconnor663/os_pipe.rs">Repo</a></li>
</ul>
<p>Usage note: The main purpose of <code>os_pipe</code> is to support the
higher-level <a href="https://github.com/oconnor663/duct.rs"><code>duct</code></a>
library, which handles most of the same use cases with much less
code and no risk of deadlocks. <code>duct</code> can run the entire example
below in <a href="https://docs.rs/duct/#example">one line of code</a>.</p>
<h1 id="changes" class="section-header"><a href="#changes">Changes</a></h1>
<ul>
<li>0.8.0
<ul>
<li>Remove the <code>From&lt;...&gt; for File</code> impls. While treating a pipe or a tty as
a file works pretty smoothly on Unix, it's questionable on Windows. For
example, <code>File::metadata</code> may return an error, or it might succeed but
then incorrectly return <code>true</code> from <code>is_file</code>. Now that the standard
library's <code>Stdin</code>/<code>Stdout</code>/<code>Stderr</code> types all implement
<code>AsRawFd</code>/<code>AsRawHandle</code>, callers who know what they're doing can use
those interfaces, rather than relying on <code>os_pipe</code>.</li>
</ul>
</li>
<li>0.7.0
<ul>
<li>Implement <code>From&lt;PipeReader&gt;</code> and <code>From&lt;PipeWriter&gt;</code> for <code>Stdio</code> and
<code>File</code>. The latter is useful for APIs that require a <code>File</code>, like
<code>memmap</code>, together with <code>dup_stdin</code> etc. below.</li>
<li>Remove the <code>IntoStdio</code> trait. Since Rust 1.20, <code>PipeReader</code> and
<code>PipeWriter</code> (as well as the standard <code>File</code>) can be passed directly to
<code>std::process::Command</code>, without any extra conversion.</li>
<li>Replace <code>parent_stdin</code>/<code>parent_stdout</code>/<code>parent_stderr</code> with
<code>dup_stdin</code>/<code>dup_stdout</code>/<code>dup_stderr</code>, which return
<code>PipeReader</code> or <code>PipeWriter</code> instead of <code>Stdio.</code></li>
</ul>
</li>
</ul>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<p>Join the stdout and stderr of a child process into a single stream,
and read it. To do that we open a pipe, duplicate its write end, and
pass those writers as the child's stdout and stderr. Then we can
read combined output from the read end of the pipe. We have to be
careful to close the write ends first though, or reading will block
waiting for EOF.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">os_pipe</span>::<span class="ident">pipe</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">process</span>::{<span class="ident">Command</span>, <span class="ident">Stdio</span>};

<span class="comment">// This command prints &quot;foo&quot; to stdout and &quot;bar&quot; to stderr. It</span>
<span class="comment">// works on both Unix and Windows, though there are whitespace</span>
<span class="comment">// differences that we&#39;ll account for at the bottom.</span>
<span class="kw">let</span> <span class="ident">shell_command</span> <span class="op">=</span> <span class="string">&quot;echo foo &amp;&amp; echo bar &gt;&amp;2&quot;</span>;

<span class="comment">// Ritual magic to run shell commands on different platforms.</span>
<span class="kw">let</span> (<span class="ident">shell</span>, <span class="ident">flag</span>) <span class="op">=</span> <span class="kw">if</span> <span class="macro">cfg</span><span class="macro">!</span>(<span class="ident">windows</span>) { (<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/C&quot;</span>) } <span class="kw">else</span> { (<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>) };

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">child</span> <span class="op">=</span> <span class="ident">Command</span>::<span class="ident">new</span>(<span class="ident">shell</span>);
<span class="ident">child</span>.<span class="ident">arg</span>(<span class="ident">flag</span>);
<span class="ident">child</span>.<span class="ident">arg</span>(<span class="ident">shell_command</span>);

<span class="comment">// Here&#39;s the interesting part. Open a pipe, copy its write end, and</span>
<span class="comment">// give both copies to the child.</span>
<span class="kw">let</span> (<span class="kw-2">mut</span> <span class="ident">reader</span>, <span class="ident">writer</span>) <span class="op">=</span> <span class="ident">pipe</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">writer_clone</span> <span class="op">=</span> <span class="ident">writer</span>.<span class="ident">try_clone</span>().<span class="ident">unwrap</span>();
<span class="ident">child</span>.<span class="ident">stdout</span>(<span class="ident">writer</span>);
<span class="ident">child</span>.<span class="ident">stderr</span>(<span class="ident">writer_clone</span>);

<span class="comment">// Now start the child running.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">handle</span> <span class="op">=</span> <span class="ident">child</span>.<span class="ident">spawn</span>().<span class="ident">unwrap</span>();

<span class="comment">// Very important when using pipes: This parent process is still</span>
<span class="comment">// holding its copies of the write ends, and we have to close them</span>
<span class="comment">// before we read, otherwise the read end will never report EOF. The</span>
<span class="comment">// Command object owns the writers now, and dropping it closes them.</span>
<span class="ident">drop</span>(<span class="ident">child</span>);

<span class="comment">// Finally we can read all the output and clean up the child.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">output</span> <span class="op">=</span> <span class="ident">String</span>::<span class="ident">new</span>();
<span class="ident">reader</span>.<span class="ident">read_to_string</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">output</span>).<span class="ident">unwrap</span>();
<span class="ident">handle</span>.<span class="ident">wait</span>().<span class="ident">unwrap</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">output</span>.<span class="ident">split_whitespace</span>().<span class="ident">eq</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>]));</pre></div>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.PipeReader.html" title='os_pipe::PipeReader struct'>PipeReader</a></td><td class='docblock-short'><p>The reading end of a pipe, returned by <a href="fn.pipe.html"><code>pipe</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.PipeWriter.html" title='os_pipe::PipeWriter struct'>PipeWriter</a></td><td class='docblock-short'><p>The writing end of a pipe, returned by <a href="fn.pipe.html"><code>pipe</code></a>.</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.dup_stderr.html" title='os_pipe::dup_stderr fn'>dup_stderr</a></td><td class='docblock-short'><p>Get a duplicated copy of the current process's standard error, as a
<a href="struct.PipeWriter.html"><code>PipeWriter</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.dup_stdin.html" title='os_pipe::dup_stdin fn'>dup_stdin</a></td><td class='docblock-short'><p>Get a duplicated copy of the current process's standard input, as a
<a href="struct.PipeReader.html"><code>PipeReader</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.dup_stdout.html" title='os_pipe::dup_stdout fn'>dup_stdout</a></td><td class='docblock-short'><p>Get a duplicated copy of the current process's standard output, as a
<a href="struct.PipeWriter.html"><code>PipeWriter</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.pipe.html" title='os_pipe::pipe fn'>pipe</a></td><td class='docblock-short'><p>Open a new pipe and return a <a href="struct.PipeReader.html"><code>PipeReader</code></a> and <a href="struct.PipeWriter.html"><code>PipeWriter</code></a> pair.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "os_pipe";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>